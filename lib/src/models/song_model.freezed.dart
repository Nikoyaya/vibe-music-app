// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'song_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Song {
  int? get id => throw _privateConstructorUsedError;
  String? get songName => throw _privateConstructorUsedError;
  String? get artistName => throw _privateConstructorUsedError;
  String? get albumName => throw _privateConstructorUsedError;
  String? get coverUrl => throw _privateConstructorUsedError;
  String? get songUrl => throw _privateConstructorUsedError;
  String? get duration => throw _privateConstructorUsedError;
  int? get playCount => throw _privateConstructorUsedError;
  int? get likeCount => throw _privateConstructorUsedError;
  DateTime? get createTime => throw _privateConstructorUsedError;
  int? get likeStatus => throw _privateConstructorUsedError;

  /// Create a copy of Song
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SongCopyWith<Song> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SongCopyWith<$Res> {
  factory $SongCopyWith(Song value, $Res Function(Song) then) =
      _$SongCopyWithImpl<$Res, Song>;
  @useResult
  $Res call(
      {int? id,
      String? songName,
      String? artistName,
      String? albumName,
      String? coverUrl,
      String? songUrl,
      String? duration,
      int? playCount,
      int? likeCount,
      DateTime? createTime,
      int? likeStatus});
}

/// @nodoc
class _$SongCopyWithImpl<$Res, $Val extends Song>
    implements $SongCopyWith<$Res> {
  _$SongCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Song
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? songName = freezed,
    Object? artistName = freezed,
    Object? albumName = freezed,
    Object? coverUrl = freezed,
    Object? songUrl = freezed,
    Object? duration = freezed,
    Object? playCount = freezed,
    Object? likeCount = freezed,
    Object? createTime = freezed,
    Object? likeStatus = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      songName: freezed == songName
          ? _value.songName
          : songName // ignore: cast_nullable_to_non_nullable
              as String?,
      artistName: freezed == artistName
          ? _value.artistName
          : artistName // ignore: cast_nullable_to_non_nullable
              as String?,
      albumName: freezed == albumName
          ? _value.albumName
          : albumName // ignore: cast_nullable_to_non_nullable
              as String?,
      coverUrl: freezed == coverUrl
          ? _value.coverUrl
          : coverUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      songUrl: freezed == songUrl
          ? _value.songUrl
          : songUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String?,
      playCount: freezed == playCount
          ? _value.playCount
          : playCount // ignore: cast_nullable_to_non_nullable
              as int?,
      likeCount: freezed == likeCount
          ? _value.likeCount
          : likeCount // ignore: cast_nullable_to_non_nullable
              as int?,
      createTime: freezed == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      likeStatus: freezed == likeStatus
          ? _value.likeStatus
          : likeStatus // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SongImplCopyWith<$Res> implements $SongCopyWith<$Res> {
  factory _$$SongImplCopyWith(
          _$SongImpl value, $Res Function(_$SongImpl) then) =
      __$$SongImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? id,
      String? songName,
      String? artistName,
      String? albumName,
      String? coverUrl,
      String? songUrl,
      String? duration,
      int? playCount,
      int? likeCount,
      DateTime? createTime,
      int? likeStatus});
}

/// @nodoc
class __$$SongImplCopyWithImpl<$Res>
    extends _$SongCopyWithImpl<$Res, _$SongImpl>
    implements _$$SongImplCopyWith<$Res> {
  __$$SongImplCopyWithImpl(_$SongImpl _value, $Res Function(_$SongImpl) _then)
      : super(_value, _then);

  /// Create a copy of Song
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? songName = freezed,
    Object? artistName = freezed,
    Object? albumName = freezed,
    Object? coverUrl = freezed,
    Object? songUrl = freezed,
    Object? duration = freezed,
    Object? playCount = freezed,
    Object? likeCount = freezed,
    Object? createTime = freezed,
    Object? likeStatus = freezed,
  }) {
    return _then(_$SongImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      songName: freezed == songName
          ? _value.songName
          : songName // ignore: cast_nullable_to_non_nullable
              as String?,
      artistName: freezed == artistName
          ? _value.artistName
          : artistName // ignore: cast_nullable_to_non_nullable
              as String?,
      albumName: freezed == albumName
          ? _value.albumName
          : albumName // ignore: cast_nullable_to_non_nullable
              as String?,
      coverUrl: freezed == coverUrl
          ? _value.coverUrl
          : coverUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      songUrl: freezed == songUrl
          ? _value.songUrl
          : songUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String?,
      playCount: freezed == playCount
          ? _value.playCount
          : playCount // ignore: cast_nullable_to_non_nullable
              as int?,
      likeCount: freezed == likeCount
          ? _value.likeCount
          : likeCount // ignore: cast_nullable_to_non_nullable
              as int?,
      createTime: freezed == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      likeStatus: freezed == likeStatus
          ? _value.likeStatus
          : likeStatus // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$SongImpl extends _Song with DiagnosticableTreeMixin {
  const _$SongImpl(
      {this.id,
      this.songName,
      this.artistName,
      this.albumName,
      this.coverUrl,
      this.songUrl,
      this.duration,
      this.playCount,
      this.likeCount,
      this.createTime,
      this.likeStatus})
      : super._();

  @override
  final int? id;
  @override
  final String? songName;
  @override
  final String? artistName;
  @override
  final String? albumName;
  @override
  final String? coverUrl;
  @override
  final String? songUrl;
  @override
  final String? duration;
  @override
  final int? playCount;
  @override
  final int? likeCount;
  @override
  final DateTime? createTime;
  @override
  final int? likeStatus;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Song(id: $id, songName: $songName, artistName: $artistName, albumName: $albumName, coverUrl: $coverUrl, songUrl: $songUrl, duration: $duration, playCount: $playCount, likeCount: $likeCount, createTime: $createTime, likeStatus: $likeStatus)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Song'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('songName', songName))
      ..add(DiagnosticsProperty('artistName', artistName))
      ..add(DiagnosticsProperty('albumName', albumName))
      ..add(DiagnosticsProperty('coverUrl', coverUrl))
      ..add(DiagnosticsProperty('songUrl', songUrl))
      ..add(DiagnosticsProperty('duration', duration))
      ..add(DiagnosticsProperty('playCount', playCount))
      ..add(DiagnosticsProperty('likeCount', likeCount))
      ..add(DiagnosticsProperty('createTime', createTime))
      ..add(DiagnosticsProperty('likeStatus', likeStatus));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SongImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.songName, songName) ||
                other.songName == songName) &&
            (identical(other.artistName, artistName) ||
                other.artistName == artistName) &&
            (identical(other.albumName, albumName) ||
                other.albumName == albumName) &&
            (identical(other.coverUrl, coverUrl) ||
                other.coverUrl == coverUrl) &&
            (identical(other.songUrl, songUrl) || other.songUrl == songUrl) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.playCount, playCount) ||
                other.playCount == playCount) &&
            (identical(other.likeCount, likeCount) ||
                other.likeCount == likeCount) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.likeStatus, likeStatus) ||
                other.likeStatus == likeStatus));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      songName,
      artistName,
      albumName,
      coverUrl,
      songUrl,
      duration,
      playCount,
      likeCount,
      createTime,
      likeStatus);

  /// Create a copy of Song
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SongImplCopyWith<_$SongImpl> get copyWith =>
      __$$SongImplCopyWithImpl<_$SongImpl>(this, _$identity);
}

abstract class _Song extends Song {
  const factory _Song(
      {final int? id,
      final String? songName,
      final String? artistName,
      final String? albumName,
      final String? coverUrl,
      final String? songUrl,
      final String? duration,
      final int? playCount,
      final int? likeCount,
      final DateTime? createTime,
      final int? likeStatus}) = _$SongImpl;
  const _Song._() : super._();

  @override
  int? get id;
  @override
  String? get songName;
  @override
  String? get artistName;
  @override
  String? get albumName;
  @override
  String? get coverUrl;
  @override
  String? get songUrl;
  @override
  String? get duration;
  @override
  int? get playCount;
  @override
  int? get likeCount;
  @override
  DateTime? get createTime;
  @override
  int? get likeStatus;

  /// Create a copy of Song
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SongImplCopyWith<_$SongImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PageResult<T> {
  List<T> get records => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;
  int get size => throw _privateConstructorUsedError;
  int get current => throw _privateConstructorUsedError;
  int get pages => throw _privateConstructorUsedError;

  /// Create a copy of PageResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PageResultCopyWith<T, PageResult<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageResultCopyWith<T, $Res> {
  factory $PageResultCopyWith(
          PageResult<T> value, $Res Function(PageResult<T>) then) =
      _$PageResultCopyWithImpl<T, $Res, PageResult<T>>;
  @useResult
  $Res call({List<T> records, int total, int size, int current, int pages});
}

/// @nodoc
class _$PageResultCopyWithImpl<T, $Res, $Val extends PageResult<T>>
    implements $PageResultCopyWith<T, $Res> {
  _$PageResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PageResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? records = null,
    Object? total = null,
    Object? size = null,
    Object? current = null,
    Object? pages = null,
  }) {
    return _then(_value.copyWith(
      records: null == records
          ? _value.records
          : records // ignore: cast_nullable_to_non_nullable
              as List<T>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as int,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PageResultImplCopyWith<T, $Res>
    implements $PageResultCopyWith<T, $Res> {
  factory _$$PageResultImplCopyWith(
          _$PageResultImpl<T> value, $Res Function(_$PageResultImpl<T>) then) =
      __$$PageResultImplCopyWithImpl<T, $Res>;
  @override
  @useResult
  $Res call({List<T> records, int total, int size, int current, int pages});
}

/// @nodoc
class __$$PageResultImplCopyWithImpl<T, $Res>
    extends _$PageResultCopyWithImpl<T, $Res, _$PageResultImpl<T>>
    implements _$$PageResultImplCopyWith<T, $Res> {
  __$$PageResultImplCopyWithImpl(
      _$PageResultImpl<T> _value, $Res Function(_$PageResultImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of PageResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? records = null,
    Object? total = null,
    Object? size = null,
    Object? current = null,
    Object? pages = null,
  }) {
    return _then(_$PageResultImpl<T>(
      records: null == records
          ? _value._records
          : records // ignore: cast_nullable_to_non_nullable
              as List<T>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as int,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PageResultImpl<T>
    with DiagnosticableTreeMixin
    implements _PageResult<T> {
  const _$PageResultImpl(
      {required final List<T> records,
      required this.total,
      required this.size,
      required this.current,
      required this.pages})
      : _records = records;

  final List<T> _records;
  @override
  List<T> get records {
    if (_records is EqualUnmodifiableListView) return _records;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_records);
  }

  @override
  final int total;
  @override
  final int size;
  @override
  final int current;
  @override
  final int pages;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PageResult<$T>(records: $records, total: $total, size: $size, current: $current, pages: $pages)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PageResult<$T>'))
      ..add(DiagnosticsProperty('records', records))
      ..add(DiagnosticsProperty('total', total))
      ..add(DiagnosticsProperty('size', size))
      ..add(DiagnosticsProperty('current', current))
      ..add(DiagnosticsProperty('pages', pages));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PageResultImpl<T> &&
            const DeepCollectionEquality().equals(other._records, _records) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.current, current) || other.current == current) &&
            (identical(other.pages, pages) || other.pages == pages));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_records),
      total,
      size,
      current,
      pages);

  /// Create a copy of PageResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PageResultImplCopyWith<T, _$PageResultImpl<T>> get copyWith =>
      __$$PageResultImplCopyWithImpl<T, _$PageResultImpl<T>>(this, _$identity);
}

abstract class _PageResult<T> implements PageResult<T> {
  const factory _PageResult(
      {required final List<T> records,
      required final int total,
      required final int size,
      required final int current,
      required final int pages}) = _$PageResultImpl<T>;

  @override
  List<T> get records;
  @override
  int get total;
  @override
  int get size;
  @override
  int get current;
  @override
  int get pages;

  /// Create a copy of PageResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PageResultImplCopyWith<T, _$PageResultImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SongListResponse {
  List<Song> get songs => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;
  int get page => throw _privateConstructorUsedError;
  int get size => throw _privateConstructorUsedError;
  int get pages => throw _privateConstructorUsedError;

  /// Create a copy of SongListResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SongListResponseCopyWith<SongListResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SongListResponseCopyWith<$Res> {
  factory $SongListResponseCopyWith(
          SongListResponse value, $Res Function(SongListResponse) then) =
      _$SongListResponseCopyWithImpl<$Res, SongListResponse>;
  @useResult
  $Res call({List<Song> songs, int total, int page, int size, int pages});
}

/// @nodoc
class _$SongListResponseCopyWithImpl<$Res, $Val extends SongListResponse>
    implements $SongListResponseCopyWith<$Res> {
  _$SongListResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SongListResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? songs = null,
    Object? total = null,
    Object? page = null,
    Object? size = null,
    Object? pages = null,
  }) {
    return _then(_value.copyWith(
      songs: null == songs
          ? _value.songs
          : songs // ignore: cast_nullable_to_non_nullable
              as List<Song>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SongListResponseImplCopyWith<$Res>
    implements $SongListResponseCopyWith<$Res> {
  factory _$$SongListResponseImplCopyWith(_$SongListResponseImpl value,
          $Res Function(_$SongListResponseImpl) then) =
      __$$SongListResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Song> songs, int total, int page, int size, int pages});
}

/// @nodoc
class __$$SongListResponseImplCopyWithImpl<$Res>
    extends _$SongListResponseCopyWithImpl<$Res, _$SongListResponseImpl>
    implements _$$SongListResponseImplCopyWith<$Res> {
  __$$SongListResponseImplCopyWithImpl(_$SongListResponseImpl _value,
      $Res Function(_$SongListResponseImpl) _then)
      : super(_value, _then);

  /// Create a copy of SongListResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? songs = null,
    Object? total = null,
    Object? page = null,
    Object? size = null,
    Object? pages = null,
  }) {
    return _then(_$SongListResponseImpl(
      songs: null == songs
          ? _value._songs
          : songs // ignore: cast_nullable_to_non_nullable
              as List<Song>,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SongListResponseImpl
    with DiagnosticableTreeMixin
    implements _SongListResponse {
  const _$SongListResponseImpl(
      {required final List<Song> songs,
      required this.total,
      required this.page,
      required this.size,
      required this.pages})
      : _songs = songs;

  final List<Song> _songs;
  @override
  List<Song> get songs {
    if (_songs is EqualUnmodifiableListView) return _songs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_songs);
  }

  @override
  final int total;
  @override
  final int page;
  @override
  final int size;
  @override
  final int pages;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SongListResponse(songs: $songs, total: $total, page: $page, size: $size, pages: $pages)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SongListResponse'))
      ..add(DiagnosticsProperty('songs', songs))
      ..add(DiagnosticsProperty('total', total))
      ..add(DiagnosticsProperty('page', page))
      ..add(DiagnosticsProperty('size', size))
      ..add(DiagnosticsProperty('pages', pages));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SongListResponseImpl &&
            const DeepCollectionEquality().equals(other._songs, _songs) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.pages, pages) || other.pages == pages));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_songs), total, page, size, pages);

  /// Create a copy of SongListResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SongListResponseImplCopyWith<_$SongListResponseImpl> get copyWith =>
      __$$SongListResponseImplCopyWithImpl<_$SongListResponseImpl>(
          this, _$identity);
}

abstract class _SongListResponse implements SongListResponse {
  const factory _SongListResponse(
      {required final List<Song> songs,
      required final int total,
      required final int page,
      required final int size,
      required final int pages}) = _$SongListResponseImpl;

  @override
  List<Song> get songs;
  @override
  int get total;
  @override
  int get page;
  @override
  int get size;
  @override
  int get pages;

  /// Create a copy of SongListResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SongListResponseImplCopyWith<_$SongListResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
